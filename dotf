#!/usr/bin/env bash
# This script was generated by bashly 1.0.3 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
    printf "bash version 4 or higher is required\n" >&2
    exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
    echo "$version"
}

# :command.usage
dotf_usage() {
    if [[ -n $long_usage ]]; then
        printf "dotf - dotfiles cli\n"
        echo

    else
        printf "dotf - dotfiles cli\n"
        echo

    fi

    printf "%s\n" "Usage:"
    printf "  dotf COMMAND\n"
    printf "  dotf [COMMAND] --help | -h\n"
    printf "  dotf --version | -v\n"
    echo
    # :command.usage_commands
    printf "%s\n" "Commands:"
    printf "  %s   sync or export layout of the directory\n" "layout"
    echo

    # :command.long_usage
    if [[ -n $long_usage ]]; then
        printf "%s\n" "Options:"

        # :command.usage_fixed_flags
        printf "  %s\n" "--help, -h"
        printf "    Show this help\n"
        echo
        printf "  %s\n" "--version, -v"
        printf "    Show version number\n"
        echo

    fi
}

# :command.usage
dotf_layout_usage() {
    if [[ -n $long_usage ]]; then
        printf "dotf layout - sync or export layout of the directory\n"
        echo

    else
        printf "dotf layout - sync or export layout of the directory\n"
        echo

    fi

    printf "%s\n" "Usage:"
    printf "  dotf layout COMMAND\n"
    printf "  dotf layout [COMMAND] --help | -h\n"
    echo
    # :command.usage_commands
    printf "%s\n" "Commands:"
    printf "  %s   Export the layout of git repository to a file\n" "git "
    printf "  %s   Sync the layout from a file\n" "sync"
    echo

    # :command.long_usage
    if [[ -n $long_usage ]]; then
        printf "%s\n" "Options:"

        # :command.usage_fixed_flags
        printf "  %s\n" "--help, -h"
        printf "    Show this help\n"
        echo

        # :command.usage_examples
        printf "%s\n" "Examples:"
        printf "  dotf layout git ~/Code/github --layout github\n"
        printf "  dotf layout sync --layout github\n"
        echo

    fi
}

# :command.usage
dotf_layout_git_usage() {
    if [[ -n $long_usage ]]; then
        printf "dotf layout git - Export the layout of git repository to a file\n"
        echo

    else
        printf "dotf layout git - Export the layout of git repository to a file\n"
        echo

    fi

    printf "%s\n" "Usage:"
    printf "  dotf layout git PATH [OPTIONS]\n"
    printf "  dotf layout git --help | -h\n"
    echo

    # :command.long_usage
    if [[ -n $long_usage ]]; then
        printf "%s\n" "Options:"

        # :command.usage_flags
        # :flag.usage
        printf "  %s\n" "--output, -o OUTPUT"
        printf "    Write layouts to file\n"
        echo

        # :flag.usage
        printf "  %s\n" "--layout LAYOUT"
        printf "    Write layouts to file in ${DOTF_LAYOUT_DIR} directory\n"
        echo

        # :flag.usage
        printf "  %s\n" "--max-depth MAX_DEPTH"
        printf "    Maximum depth to locate git repository in the path\n"
        printf "    Default: 4\n"
        echo

        # :flag.usage
        printf "  %s\n" "--dry-run, -n"
        printf "    Show what layouts will be export (not actually run)\n"
        echo

        # :command.usage_fixed_flags
        printf "  %s\n" "--help, -h"
        printf "    Show this help\n"
        echo

        # :command.usage_args
        printf "%s\n" "Arguments:"

        # :argument.usage
        printf "  %s\n" "PATH"
        printf "    Path of the git repository\n"
        echo

    fi
}

# :command.usage
dotf_layout_sync_usage() {
    if [[ -n $long_usage ]]; then
        printf "dotf layout sync - Sync the layout from a file\n"
        echo

    else
        printf "dotf layout sync - Sync the layout from a file\n"
        echo

    fi

    printf "%s\n" "Usage:"
    printf "  dotf layout sync [OPTIONS]\n"
    printf "  dotf layout sync --help | -h\n"
    echo

    # :command.long_usage
    if [[ -n $long_usage ]]; then
        printf "%s\n" "Options:"

        # :command.usage_flags
        # :flag.usage
        printf "  %s\n" "--source, -s SOURCE"
        printf "    Read layouts from the file\n"
        echo

        # :flag.usage
        printf "  %s\n" "--layout LAYOUT"
        printf "    Read layouts from ${DOTF_LAYOUT_DIR} directory\n"
        echo

        # :flag.usage
        printf "  %s\n" "--dry-run, -n"
        printf "    Show what layouts will be sync (not actually run)\n"
        echo

        # :command.usage_fixed_flags
        printf "  %s\n" "--help, -h"
        printf "    Show this help\n"
        echo

    fi
}

# :command.normalize_input
normalize_input() {
    local arg flags

    while [[ $# -gt 0 ]]; do
        arg="$1"
        if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
            input+=("${BASH_REMATCH[1]}")
            input+=("${BASH_REMATCH[2]}")
        elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
            input+=("${BASH_REMATCH[1]}")
            input+=("${BASH_REMATCH[2]}")
        elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
            flags="${BASH_REMATCH[1]}"
            for ((i = 0; i < ${#flags}; i++)); do
                input+=("-${flags:i:1}")
            done
        else
            input+=("$arg")
        fi

        shift
    done
}
# :command.inspect_args
inspect_args() {
    if ((${#args[@]})); then
        readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
        echo args:
        for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
    else
        echo args: none
    fi

    if ((${#other_args[@]})); then
        echo
        echo other_args:
        echo "- \${other_args[*]} = ${other_args[*]}"
        for i in "${!other_args[@]}"; do
            echo "- \${other_args[$i]} = ${other_args[$i]}"
        done
    fi

    if ((${#deps[@]})); then
        readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
        echo
        echo deps:
        for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
    fi

}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
    local color="$1"
    shift
    if [[ -z ${NO_COLOR+x} ]]; then
        printf "$color%b\e[0m\n" "$*"
    else
        printf "%b\n" "$*"
    fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/consts.sh
DOTF_ROOT="${HOME}/.dotfiles"
DOTF_PKG_DIR="${DOTF_ROOT}/packages"
DOTF_LAYOUT_DIR="${DOTF_PKG_DIR}/os/layouts"

# src/lib/message.sh
utils::message::format() {
    local prefix="$1"
    shift
    local format="$1"
    shift
    printf "${prefix}: ${format}\n" "$@"
}

utils::message::info() {
    local msg="$(utils::message::format "INFO" "$@")"
    green "${msg}"
}

utils::message::warning() {
    local msg="$(utils::message::format "WARNING" "$@")"
    yellow "${msg}"
}

utils::message::error() {
    local msg="$(utils::message::format "ERROR" "$@")"
    red "${msg}" >&2
}

utils::message::fatal() {
    utils::message::error "$@"
    exit 1
}

# src/lib/utils.sh
utils::boolean::is_true() {
    case "$1" in
        true | yes | 1)
            true
            return
            ;;
        *)
            false
            return
            ;;
    esac
}

utils::boolean::is_false() {
    case "$1" in
        false | no | 0)
            true
            return
            ;;
        *)
            false
            return
            ;;
    esac
}

# :command.command_functions

# :command.function
dotf_layout_git_command() {
    # src/layout/git.sh
    local path="${args[path]%/}"
    local output="${args[--output]}"
    local layout="${args[--layout]}"
    local max_depth="${args["--max-depth"]}"
    local dry_run="${args["--dry-run"]}"

    if [[ -z "${output}" ]]; then
        if [[ -n "${layout}" ]]; then
            output="${DOTF_LAYOUT_DIR}/${layout}"
        else
            utils::message::fatal "missing --output or --layout, please see --help for detail."
        fi
    fi

    if ! utils::boolean::is_true "${dry_run}"; then
        local output_dir="$(dirname "${output}")"
        mkdir -p "${output_dir}"
        # Clear layout file content
        >"${output}"
    fi

    find "${path}" -maxdepth "${max_depth}" -name ".git" ! -path '*/.local/*' | sort | while read filename; do
        local filedir=$(dirname "${filename}")
        local url="$(git -C "${filedir}" config --get remote.origin.url)"
        local target="${filedir/#${HOME}/\~}"
        if utils::boolean::is_true "${dry_run}"; then
            utils::message::warning "[Simulate] ${target} ==> ${url}"
        else
            local line="${target};${url}\n"
            printf "${line}" >>"${output}"
        fi
    done

}

# :command.function
dotf_layout_sync_command() {
    # src/layout/sync.sh
    local source="${args[--source]}"
    local layout="${args[--layout]}"
    local dry_run="${args["--dry-run"]}"

    if [[ -z "${source}" ]]; then
        if [[ -n "${layout}" ]]; then
            source="${DOTF_LAYOUT_DIR}/${layout}"
        else
            utils::message::fatal "missing --source or --layout, please see --help for detail."
        fi
    fi
    if [[ ! -f "${source}" ]]; then
        utils::message::fatal "'%s' not exists." "${source}"
    fi

    while read line; do
        set -f # avoid globbing (expansion of *).
        local parts=(${line/;/ })
        local path="${parts[0]/#\~/${HOME}}"
        local url="${parts[1]}"
        if [[ ! -d "${path}" ]]; then
            local msg="git clone '${url}' to '${path}'"
            if utils::boolean::is_true "${dry_run}"; then
                utils::message::warning "[Simulate] ${msg}"
            else
                echo "${msg}"
                git clone "${url}" "${path}" && echo
            fi
        fi
    done <${source}

}

# :command.parse_requirements
parse_requirements() {
    # :command.fixed_flags_filter
    while [[ $# -gt 0 ]]; do
        case "${1:-}" in
            --version | -v)
                version_command
                exit
                ;;

            --help | -h)
                long_usage=yes
                dotf_usage
                exit
                ;;

            *)
                break
                ;;

        esac
    done

    # :command.command_filter
    action=${1:-}

    case $action in
        -*) ;;

        layout)
            action="layout"
            shift
            dotf_layout_parse_requirements "$@"
            shift $#
            ;;

        # :command.command_fallback
        "")
            dotf_usage >&2
            exit 1
            ;;

        *)
            printf "invalid command: %s\n" "$action" >&2
            exit 1
            ;;

    esac

    # :command.parse_requirements_while
    while [[ $# -gt 0 ]]; do
        key="$1"
        case "$key" in

            -?*)
                printf "invalid option: %s\n" "$key" >&2
                exit 1
                ;;

            *)
                # :command.parse_requirements_case
                # :command.parse_requirements_case_simple
                printf "invalid argument: %s\n" "$key" >&2
                exit 1

                ;;

        esac
    done

}

# :command.parse_requirements
dotf_layout_parse_requirements() {
    # :command.fixed_flags_filter
    while [[ $# -gt 0 ]]; do
        case "${1:-}" in
            --help | -h)
                long_usage=yes
                dotf_layout_usage
                exit
                ;;

            *)
                break
                ;;

        esac
    done

    # :command.command_filter
    action=${1:-}

    case $action in
        -*) ;;

        git)
            action="git"
            shift
            dotf_layout_git_parse_requirements "$@"
            shift $#
            ;;

        sync)
            action="sync"
            shift
            dotf_layout_sync_parse_requirements "$@"
            shift $#
            ;;

        # :command.command_fallback
        "")
            dotf_layout_usage >&2
            exit 1
            ;;

        *)
            printf "invalid command: %s\n" "$action" >&2
            exit 1
            ;;

    esac

    # :command.parse_requirements_while
    while [[ $# -gt 0 ]]; do
        key="$1"
        case "$key" in

            -?*)
                printf "invalid option: %s\n" "$key" >&2
                exit 1
                ;;

            *)
                # :command.parse_requirements_case
                # :command.parse_requirements_case_simple
                printf "invalid argument: %s\n" "$key" >&2
                exit 1

                ;;

        esac
    done

}

# :command.parse_requirements
dotf_layout_git_parse_requirements() {
    # :command.fixed_flags_filter
    while [[ $# -gt 0 ]]; do
        case "${1:-}" in
            --help | -h)
                long_usage=yes
                dotf_layout_git_usage
                exit
                ;;

            *)
                break
                ;;

        esac
    done

    # :command.command_filter
    action="layout git"

    # :command.parse_requirements_while
    while [[ $# -gt 0 ]]; do
        key="$1"
        case "$key" in
            # :flag.case
            --output | -o)
                # :flag.conflicts
                if [[ -n "${args['--layout']:-}" ]]; then
                    printf "conflicting options: %s cannot be used with %s\n" "$key" "--layout" >&2
                    exit 1
                fi

                # :flag.case_arg
                if [[ -n ${2+x} ]]; then

                    args['--output']="$2"
                    shift
                    shift
                else
                    printf "%s\n" "--output requires an argument: --output, -o OUTPUT" >&2
                    exit 1
                fi
                ;;

            # :flag.case
            --layout)
                # :flag.conflicts
                if [[ -n "${args['--output']:-}" ]]; then
                    printf "conflicting options: %s cannot be used with %s\n" "$key" "--output" >&2
                    exit 1
                fi

                # :flag.case_arg
                if [[ -n ${2+x} ]]; then

                    args['--layout']="$2"
                    shift
                    shift
                else
                    printf "%s\n" "--layout requires an argument: --layout LAYOUT" >&2
                    exit 1
                fi
                ;;

            # :flag.case
            --max-depth)

                # :flag.case_arg
                if [[ -n ${2+x} ]]; then

                    args['--max-depth']="$2"
                    shift
                    shift
                else
                    printf "%s\n" "--max-depth requires an argument: --max-depth MAX_DEPTH" >&2
                    exit 1
                fi
                ;;

            # :flag.case
            --dry-run | -n)

                # :flag.case_no_arg
                args['--dry-run']=1
                shift
                ;;

            -?*)
                printf "invalid option: %s\n" "$key" >&2
                exit 1
                ;;

            *)
                # :command.parse_requirements_case
                # :command.parse_requirements_case_simple
                if [[ -z ${args['path']+x} ]]; then

                    args['path']=$1
                    shift
                else
                    printf "invalid argument: %s\n" "$key" >&2
                    exit 1
                fi

                ;;

        esac
    done

    # :command.required_args_filter
    if [[ -z ${args['path']+x} ]]; then
        printf "missing required argument: PATH\nusage: dotf layout git PATH [OPTIONS]\n" >&2
        exit 1
    fi

    # :command.default_assignments
    [[ -n ${args['--max-depth']:-} ]] || args['--max-depth']="4"

}

# :command.parse_requirements
dotf_layout_sync_parse_requirements() {
    # :command.fixed_flags_filter
    while [[ $# -gt 0 ]]; do
        case "${1:-}" in
            --help | -h)
                long_usage=yes
                dotf_layout_sync_usage
                exit
                ;;

            *)
                break
                ;;

        esac
    done

    # :command.command_filter
    action="layout sync"

    # :command.parse_requirements_while
    while [[ $# -gt 0 ]]; do
        key="$1"
        case "$key" in
            # :flag.case
            --source | -s)
                # :flag.conflicts
                if [[ -n "${args['--layout']:-}" ]]; then
                    printf "conflicting options: %s cannot be used with %s\n" "$key" "--layout" >&2
                    exit 1
                fi

                # :flag.case_arg
                if [[ -n ${2+x} ]]; then

                    args['--source']="$2"
                    shift
                    shift
                else
                    printf "%s\n" "--source requires an argument: --source, -s SOURCE" >&2
                    exit 1
                fi
                ;;

            # :flag.case
            --layout)
                # :flag.conflicts
                if [[ -n "${args['--file']:-}" ]]; then
                    printf "conflicting options: %s cannot be used with %s\n" "$key" "--file" >&2
                    exit 1
                fi

                # :flag.case_arg
                if [[ -n ${2+x} ]]; then

                    args['--layout']="$2"
                    shift
                    shift
                else
                    printf "%s\n" "--layout requires an argument: --layout LAYOUT" >&2
                    exit 1
                fi
                ;;

            # :flag.case
            --dry-run | -n)

                # :flag.case_no_arg
                args['--dry-run']=1
                shift
                ;;

            -?*)
                printf "invalid option: %s\n" "$key" >&2
                exit 1
                ;;

            *)
                # :command.parse_requirements_case
                # :command.parse_requirements_case_simple
                printf "invalid argument: %s\n" "$key" >&2
                exit 1

                ;;

        esac
    done

}

# :command.initialize
initialize() {
    version="0.1.0"
    long_usage=''
    set -e

}

# :command.run
run() {
    declare -A args=()
    declare -A deps=()
    declare -a other_args=()
    declare -a input=()
    normalize_input "$@"
    parse_requirements "${input[@]}"

    case "$action" in
        "layout") dotf_layout_command ;;
        "layout git") dotf_layout_git_command ;;
        "layout sync") dotf_layout_sync_command ;;
    esac
}

initialize
run "$@"
